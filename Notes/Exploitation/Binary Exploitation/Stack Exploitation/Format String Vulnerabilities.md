# Introduction
The C language provides certain functionality for converting variables into human-readable strings. This can be seen in functions like `printf`. For example, the following code will combine the string `"Printing the magic number... The magic number is "` with the number stored in `a`.

```cpp
int a = 2;
printf("Printing the magic number... The magic number is %d\n.", &a);
```

The first argument is called the format string and `%d` is known as a format parameter. When using a variable as a format argument, you need to pass its address. There also exist multiple format parameters:

| Parameter | Meaning | Passed as |
|:----------:|:---------|:----------:|
| %p | Prints the argument as a pointer | Value |
|%%| Prints a % character| Value |
| %d| Prints a signed decimal number | Value |
| %u| Prints an unsigned decimal number| Value |
| %x| Prints the argument as a hexadecimal number| Value |
|%s| Prints a string| Pointer |
|%n| Prints nothing, but stores the number of bytes written so far in the location specified by the pointer passed as an argument | Pointer |

When `printf` is invoked, it goes backwards from the beginning of its stack frame through the stack in order to retrieve its arguments one by one. If a format string is specified but no actual arguments are pushed to the stack before the function is invoked, for every format parameter `printf` will go backwards through the stack. This will lead to the erroneous interpretation of stack memory and can lead to memory leaks. Furthermore, the `%n` format parameter can be utilised for writing arbitrary memory by manipulating the pointer into which it should store the number of bytes written so far. Consequently, format string vulnerabilities can beget arbitrary code execution by overwriting the GOT.

# The Essence of a Format String Vulnerability
Format string vulnerabilities occur when the format string of a function such as `printf` is passed directly as a buffer which can be manipulated by an attacker. The buffer itself may contain format characters which can be abused in arbitrary ways.

```cpp
char input[100];
scanf("%100s", input);

printf(input);
```

This code is abominable, since the `input` buffer is entirely controlled by the user. If any format parameters are included in the buffer, `printf` will treat them accordingly and this can result in all sorts of mishaps. The correct way to implement such code is to actually pass the user input as a format argument to a format string in `printf`:

```cpp
char input[100];
scanf("%100s", input);

printf("%100s", input);
```

# Examples
## Leaking Memory
Format string vulnerabilities can be easily exploited to leak memory on the stack. This is typically done through the use of the `%p` or `%x` format parameters. Filling a format string with those parameters will continously leak stack memory. Sometimes, however, the buffer we are writing to doesn't have enough space to store enough parameters for us to reach the value we want to leak. Luckily, C has some syntax sugar which allows us to retrieve a particular argument. This is done by using `%n$parameter`, where `n` is the number of the argument we want to access and `parameter` is the format parameter we want to use. Consequently, if we want to print the third value on the stack as a pointer, we would use `%n$p`.

Here is a simple example of such an attack.

leaking_memory.c:

```cpp
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(void)
{

int input = 0;
int key = 0xdeadbeef;
char message[100];

printf("Enter a message to be sent:\n");

fgets(message, sizeof(message), stdin);

printf("The following message will be sent: \n");
printf(message);

printf("Enter the secret key in order to send the message. \n");
scanf("%d", &input);

if (input == key)
{
	printf("Message successfully sent!\n");
}
else
{
	printf("Failed to send message!\n");
}


return 0;
}
```

![](Resources/Images/FSV_leak.png)

