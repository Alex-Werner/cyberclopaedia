# Introduction
A block cipher is an encryption scheme which works on plaintexts of a fixed size. Furthermore, it is usually paired with a *mode of operation*. The size is typically small, such as 64 or 128 bits, although, it is possible to have smaller or larger block sizes. Large block sizes have a lofty memory footprint and are less efficient. It is, however, paramount that the block size is also not too small lest the cipher becomes vulnerable to a codebook attack. This attack is actuated by the construction of a look-up table which contains all possible plaintext-ciphertext pairs generated by a given block cipher and can be easily used to look up a plaintext given its ciphertext. For example, a block size of 16 requires only $2^{16} \times 2^{16} = 2^{20}$ bits of memory, which is equal to 128 kilobytes. With the 32-bit blocks, the memory needs grow to 16 gigabytes which is still feasible. However, with a block size of 64 bits, the memory required shoots up to $2^{70}$ bits. Good luck storing that.

# Anatomy of a Block Cipher
Block ciphers represent a repetition of *rounds*, which are short and simple sequences of operation. The strength of a block cipher lies not in its complexity, but rather its repetitiveness. The ciphertext of a given block is the sequence of rounds applied to the plaintext: $c = R_3(R_2(R_1(p, {k^{\prime}}), {k^{\prime\prime}}),{k^{\prime\prime\prime}})$. In addition to the output of the previous round, each round also takes in a *round key*. The round keys $k^{\prime},k^{\prime\prime},k^{\prime\prime\prime},...$ are generated from the master key $k$ through an algorithm bearing the name *key schedule*. The round functions $R_1, R_2,...$ are usually the same algorithm which why it is crucial that they are provided with different round keys in order to generate different outputs.

## Slide Attacks and Round Keys
Repeating round keys open room for *slide attacks*. These look for plaintext-ciphertext pairs $(p_1, c_1)$ and $(p_2, c_2)$ where $p_2 = R(p_1)$. Since both the round algorithm and key are identical, then if $p_2 = R(p_1)$ implies that $c_2 = R(c_1)$. This relationship will hold true no matter how many repetitions of the round the plaintext goes through.

![](Resources/Images/Block_Cipher_Ciphertext_Stealing.png)

# Modes of Operation
It's all well and good with block ciphers when encrypting messages whose length matches the block size, but what happens if we want to encrypt a plaintext that is longer than a single block? Well, here comes the use of a *mode of operation*. If the message is longer than the block size, then it must be split into blocks of the desired size. From then on, the mode of operation describes how each of the blocks is encrypted and how the resulting ciphertexts are combined into the final output.

## The Electronic Codebook (ECB) Mode
This is the simplest mode of operation you could think of. It encrypts each plaintext block independently and then just concatenates the resulting ciphertexts. 

![](Resources/Images/Block_Cipher_ECB_Encrypt.png)

This mode is abominably insecure, since it is *pattern preserving*. While patterns inside each block are destroyed (a proper encryption algorithm should take care of that), patterns between blocks are ultimately preserved. To illustrate, let's say that you want to encrypt the number 19281267. If you have 4-bit blocks, you would encrypt the blocks 1928 and 1267. Suppose, that these get encrypted to 4765 and 4104. If you check, subtracting the second plaintext block from the first yields the same result as subtracting the second ciphertext from the first, namely 661. An infamous example of this is the ECB penguin. Encrypting an image with ECB will yield the same image with merely a distorted colour scheme.

![](Resources/Images/Block_Cipher_ECB_Penguin.png)

## The Cipher Block Chaining (CBC) Mode
Cipher block chaining resembles ECB, but it actually incorporates the previous block into the encryption of the current one. Instead of encrypting the $i$th block $p_i$ as $c_i = Enc_k(p_i)$, cipher block chaining XORs the plaintext with the previous ciphertext: $c_i = Enc_k(p_i \bigoplus c_{i-1})$. The first plaintext is XOR-ed with a random value called an *initialisation vector (IV)*.

![](Resources/Images/Block_Cipher_CBC_Encrypt.png)

Since each consecutive block depends on the previous one, patterns between blocks are destroyed. Furthermore, if the IV is different each time, two identical plaintexts will produce disparate ciphertexts when encrypted. Note, that for decryption, the IV needs to be known. It is also interesting to mention that CBC decryption can be much faster than encryption due to parallelism. When encrypting, each new block needs to wait for the previous one to be encrypted in order to get its ciphertext, however, with decryption all ciphertexts are already known, so it can optimised on multiple threads.

## The Counter (CTR) Mode
The Counter mode is a bit different to the ones described above. It turns a block cipher into a stream cipher - in fact, it doesn't even encrypt the blocks themselves! 
This mode is comprised of an IV, often in this case called a *nonce*, and a counter. The counter may be any function which is guaranteed to generate a sequence which will not repeat for a long time. That being said, it is still very common to just use a simple increment-by-one counter. 

The way that the CTR mode works is by taking the nonce and the counter for the current block (the counter is incremented for each block) and combining them together. If the nonce is random, it may be combined with the counter by means of any invertible operation such as addition, concatenation, or XOR-ing. Should that not be the case, then the nonce and the counter should be concatenated, since simply adding or XOR-ing them would break the security under a chosen plaintext attack, since an attacker may be able to manipulate the entire nonceâ€“counter pair to cause a collision. Once they have control over the nonce-counter pair and plaintext, XOR-ing the ciphertext with the plaintext would produce a value that can be XOR-ed with the other block sharing the same nonce-counter pair in order to decrypt it.

After this, the nonce-counter pair is encrypted with the key and then XOR-ed with the plaintext block in order to produce the ciphertext.

![](Resources/Images/Block_Cipher_CTR_encrypt.png)

It is paramount that the nonce is unique between messages, since when encrypting two plaintexts with the same nonce-counter stream - $c_1 = p_1 \bigoplus S$ and $c_2 = p_2 \bigoplus S$, then $c_1 \bigoplus c_2$ reveals $p_1 \bigoplus p_2$.

Furthermore, a random nonce is sufficient only if it is long enough. Given a nonce of length $n$ bits, it is likely that after $2^{n/2}$ encryptions collisions will start occuring. Therefore, a 64-bit nonce is abominable due to the fact that collisions will commence after approximately $2^{32}$ encryptions, which is a very low number. 

Decryption works by XOR-ing the ciphertext with the appropriate nonce-counter pair.

A particular benefit of the CTR mode is that it is parallelisable and can thus execute rather quickly. You can even begin encryption before having the message to encrypt by selecting a nonce and computing the nonce-counter stream which will be later XOR-ed with the plaintext.

## Encrypting Non-Conforming Messages
A non-conforming message is a message whose length is not evenly divisible by the block size. For example, you might have a message of size 18 bytes and a block size of 16 bytes. In this case, there are two main ways to resolve the issue.

### Message Padding
Padding allows for the encryption of messages of arbitrary lengths, even ones which are shorter than a single block. It is used to expand a message in order to fill a complete block by appending bytes to the plaintext and it is a highly standardised procedure. 

The most common padding algorithm is described by PKCS#7 in RFC 5652.

Given a block size, $n$, and a message of length $m$, the message is padded with $n-m$ number of bytes of value $n-m$.  A concrete example with 16-byte blocks is the following:
- If there's is one byte left until the message length is divisible by 16 - for example, it is 17 or 33 bytes long - then pad the message with 15 bytes `0x0f` (15 in decimal).
- If there are two bytes left until the message length is divisible by 16 - for example, it is 18 or 34 bytes long - then pad the message with 14 bytes `0x0e` (14 in decimal).
- If there are three bytes left until the message length is divisible by 16, then pad the message with 13 bytes `0x0d` (13 in decimal), and so on.

If the message length is already divisible by the block size, then an additional *block* containing bytes with value equal to the block size is appended in order to signify to the decryption algorithm whether the last block is part of the plaintext or just padding. In the above example, if the message length was already divisible by 16, then another 16 bytes of value `0x10` would have been appended to it.

Decryption is fairly simple and works by first deciphering all the unpadded blocks. Subsequently, the last block is decrypted and the last bytes of the resulting plaintext are checked for conformity with the aforementioned scheme. If such is not found, the message is rejected. Otherwise, the padding bytes are stripped before returning the plaintext.

### Ciphertext Stealing
Ciphertext stealing is another technique for encrypting messages of arbitrary length. Whilst more complex, it has several benefits:
- Plaintexts are allowed to be of any *bit* length and are not restrained to bytes - it is possible to encrypt a message which is 155 bits long.
- Ciphertext have the same length as plaintexts.

In CBC mode, ciphertext stealing extends the last incomplete plaintext block by taking bits from the previous ciphertext block, thus splitting the penultimate ciphertext block. Once the last plaintext block is complete, it is encrypted and its ciphertext is placed as the penultimate ciphertext block. Now, the first bits (the ones which were not appended) of the broken ciphertext block are placed at the end as a reduced ciphertext block, meaning that the last ciphertext block has a length less than the block size.

![](Resources/Images/Block_Cipher_Ciphertext_Stealing.png)
