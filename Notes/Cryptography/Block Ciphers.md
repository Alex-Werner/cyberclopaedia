# Introduction
A block cipher is an encryption scheme which works on plaintexts of a fixed size. Furthermore, it is usually paired with a *mode of operation*. The size is typically small, such as 64 or 128 bits, although, it is possible to have smaller or larger block sizes. Large block sizes have a lofty memory footprint and are less efficient. It is, however, paramount that the block size is also not too small lest the cipher becomes vulnerable to a codebook attack. This attack is actuated by the construction of a look-up table which contains all possible plaintext-ciphertext pairs generated by a given block cipher and can be easily used to look up a plaintext given its ciphertext. For example, a block size of 16 requires only $2^{16} \times 2^{16} = 2^{20}$ bits of memory, which is equal to 128 kilobytes. With the 32-bit blocks, the memory needs grow to 16 gigabytes which is still feasible. However, with a block size of 64 bits, the memory required shoots up to $2^{70}$ bits. Good luck storing that.

# Anatomy of a Block Cipher
Block ciphers represent a repetition of *rounds*, which are short and simple sequences of operation. The strength of a block cipher lies not in its complexity, but rather its repetitiveness. The ciphertext of a given block is the sequence of rounds applied to the plaintext: $c = R_3(R_2(R_1(p, {k^{\prime}}), {k^{\prime\prime}}),{k^{\prime\prime\prime}})$. In addition to the output of the previous round, each round also takes in a *round key*. The round keys $k^{\prime},k^{\prime\prime},k^{\prime\prime\prime},...$ are generated from the master key $k$ through an algorithm bearing the name *key schedule*. The round functions $R_1, R_2,...$ are usually the same algorithm which why it is crucial that they are provided with different round keys in order to generate different outputs.

## Slide Attacks and Round Keys
Repeating round keys open room for *slide attacks*. These look for plaintext-ciphertext pairs $(p_1, c_1)$ and $(p_2, c_2)$ where $p_2 = R(p_1)$. Since both the round algorithm and key are identical, then if $p_2 = R(p_1)$ implies that $c_2 = R(c_1)$. This relationship will hold true no matter how many repetitions of the round the plaintext goes through.

![](Resources/Images/Block_Cipher_Slide_Attack.png)

# Modes of Operation
It's all well and good with block ciphers when encrypting messages whose length matches the block size, but what happens if we want to encrypt a plaintext that is longer than a single block? Well, here comes the use of a *mode of operation*. If the message is longer than the block size, then it must be split into blocks of the desired size. From then on, the mode of operation describes how each of the blocks is encrypted and how the resulting ciphertexts are combined into the final output.

## The Electronic Codebook (ECB) Mode
This is the simplest mode of operation you could think of. It encrypts each plaintext block independently and then just concatenates the resulting ciphertexts. This mode is abominably insecure, since it is *pattern preserving*. While patterns inside each block are destroyed (a proper encryption algorithm should take care of that), patterns between blocks are ultimately preserved. To illustrate, let's say that you want to encrypt the number 19281267. If you have 4-bit blocks, you would encrypt the blocks 1928 and 1267. Suppose, that these get encrypted to 4765 and 4104. If you check, subtracting the second plaintext block from the first yields the same result as subtracting the second ciphertext from the first, namely 661. An infamous example of this is the ECB penguin. Encrypting an image with ECB will yield the same image with merely a distorted colour scheme.

![](Resources/Images/Block_Cipher_ECB_Penguin.png)

